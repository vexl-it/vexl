diff --git a/lib/_stream_writable.js b/lib/_stream_writable.js
index e1e897ff3b098a263aa105d5704dbadce42d5862..3ff576f66163605c12dd8204c6b53959f0d8ed29 100644
--- a/lib/_stream_writable.js
+++ b/lib/_stream_writable.js
@@ -23,11 +23,11 @@
 // Implement an async ._write(chunk, encoding, cb), and it'll handle all
 // the drain event emission and buffering.
 
-'use strict';
+"use strict";
 
 /*<replacement>*/
 
-var pna = require('process-nextick-args');
+var pna = require("process-nextick-args");
 /*</replacement>*/
 
 module.exports = Writable;
@@ -54,7 +54,11 @@ function CorkedRequest(state) {
 /* </replacement> */
 
 /*<replacement>*/
-var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
+var asyncWrite =
+  !process.browser &&
+  ["v0.10", "v0.9."].indexOf(process.version?.slice(0, 5)) > -1
+    ? setImmediate
+    : pna.nextTick;
 /*</replacement>*/
 
 /*<replacement>*/
@@ -64,24 +68,32 @@ var Duplex;
 Writable.WritableState = WritableState;
 
 /*<replacement>*/
-var util = Object.create(require('core-util-is'));
-util.inherits = require('inherits');
+var util = Object.create(require("core-util-is"));
+util.inherits = require("inherits");
 /*</replacement>*/
 
 /*<replacement>*/
 var internalUtil = {
-  deprecate: require('util-deprecate')
+  deprecate: require("util-deprecate"),
 };
 /*</replacement>*/
 
 /*<replacement>*/
-var Stream = require('./internal/streams/stream');
+var Stream = require("./internal/streams/stream");
 /*</replacement>*/
 
 /*<replacement>*/
 
-var Buffer = require('safe-buffer').Buffer;
-var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
+var Buffer = require("safe-buffer").Buffer;
+var OurUint8Array =
+  (typeof global !== "undefined"
+    ? global
+    : typeof window !== "undefined"
+    ? window
+    : typeof self !== "undefined"
+    ? self
+    : {}
+  ).Uint8Array || function () {};
 function _uint8ArrayToBuffer(chunk) {
   return Buffer.from(chunk);
 }
@@ -91,14 +103,14 @@ function _isUint8Array(obj) {
 
 /*</replacement>*/
 
-var destroyImpl = require('./internal/streams/destroy');
+var destroyImpl = require("./internal/streams/destroy");
 
 util.inherits(Writable, Stream);
 
 function nop() {}
 
 function WritableState(options, stream) {
-  Duplex = Duplex || require('./_stream_duplex');
+  Duplex = Duplex || require("./_stream_duplex");
 
   options = options || {};
 
@@ -113,7 +125,8 @@ function WritableState(options, stream) {
   // contains buffers or objects.
   this.objectMode = !!options.objectMode;
 
-  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
+  if (isDuplex)
+    this.objectMode = this.objectMode || !!options.writableObjectMode;
 
   // the point at which write() starts returning false
   // Note: 0 is a valid value, means that we always return false if
@@ -122,7 +135,10 @@ function WritableState(options, stream) {
   var writableHwm = options.writableHighWaterMark;
   var defaultHwm = this.objectMode ? 16 : 16 * 1024;
 
-  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;
+  if (hwm || hwm === 0) this.highWaterMark = hwm;
+  else if (isDuplex && (writableHwm || writableHwm === 0))
+    this.highWaterMark = writableHwm;
+  else this.highWaterMark = defaultHwm;
 
   // cast to ints.
   this.highWaterMark = Math.floor(this.highWaterMark);
@@ -151,7 +167,7 @@ function WritableState(options, stream) {
   // Crypto is kind of old and crusty.  Historically, its default string
   // encoding is 'binary' so we have to make this configurable.
   // Everything else in the universe uses 'utf8', though.
-  this.defaultEncoding = options.defaultEncoding || 'utf8';
+  this.defaultEncoding = options.defaultEncoding || "utf8";
 
   // not an actual buffer we keep track of, but a measurement
   // of how much we're waiting to get pushed to some underlying
@@ -220,10 +236,15 @@ WritableState.prototype.getBuffer = function getBuffer() {
 
 (function () {
   try {
-    Object.defineProperty(WritableState.prototype, 'buffer', {
-      get: internalUtil.deprecate(function () {
-        return this.getBuffer();
-      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
+    Object.defineProperty(WritableState.prototype, "buffer", {
+      get: internalUtil.deprecate(
+        function () {
+          return this.getBuffer();
+        },
+        "_writableState.buffer is deprecated. Use _writableState.getBuffer " +
+          "instead.",
+        "DEP0003"
+      ),
     });
   } catch (_) {}
 })();
@@ -231,7 +252,11 @@ WritableState.prototype.getBuffer = function getBuffer() {
 // Test _writableState for inheritance to account for Duplex streams,
 // whose prototype chain only points to Readable.
 var realHasInstance;
-if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
+if (
+  typeof Symbol === "function" &&
+  Symbol.hasInstance &&
+  typeof Function.prototype[Symbol.hasInstance] === "function"
+) {
   realHasInstance = Function.prototype[Symbol.hasInstance];
   Object.defineProperty(Writable, Symbol.hasInstance, {
     value: function (object) {
@@ -239,7 +264,7 @@ if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.protot
       if (this !== Writable) return false;
 
       return object && object._writableState instanceof WritableState;
-    }
+    },
   });
 } else {
   realHasInstance = function (object) {
@@ -248,7 +273,7 @@ if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.protot
 }
 
 function Writable(options) {
-  Duplex = Duplex || require('./_stream_duplex');
+  Duplex = Duplex || require("./_stream_duplex");
 
   // Writable ctor is applied to Duplexes, too.
   // `realHasInstance` is necessary because using plain `instanceof`
@@ -267,13 +292,13 @@ function Writable(options) {
   this.writable = true;
 
   if (options) {
-    if (typeof options.write === 'function') this._write = options.write;
+    if (typeof options.write === "function") this._write = options.write;
 
-    if (typeof options.writev === 'function') this._writev = options.writev;
+    if (typeof options.writev === "function") this._writev = options.writev;
 
-    if (typeof options.destroy === 'function') this._destroy = options.destroy;
+    if (typeof options.destroy === "function") this._destroy = options.destroy;
 
-    if (typeof options.final === 'function') this._final = options.final;
+    if (typeof options.final === "function") this._final = options.final;
   }
 
   Stream.call(this);
@@ -281,13 +306,13 @@ function Writable(options) {
 
 // Otherwise people can pipe Writable streams, which is just wrong.
 Writable.prototype.pipe = function () {
-  this.emit('error', new Error('Cannot pipe, not readable'));
+  this.emit("error", new Error("Cannot pipe, not readable"));
 };
 
 function writeAfterEnd(stream, cb) {
-  var er = new Error('write after end');
+  var er = new Error("write after end");
   // TODO: defer error events consistently everywhere, not just the cb
-  stream.emit('error', er);
+  stream.emit("error", er);
   pna.nextTick(cb, er);
 }
 
@@ -299,12 +324,16 @@ function validChunk(stream, state, chunk, cb) {
   var er = false;
 
   if (chunk === null) {
-    er = new TypeError('May not write null values to stream');
-  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
-    er = new TypeError('Invalid non-string/buffer chunk');
+    er = new TypeError("May not write null values to stream");
+  } else if (
+    typeof chunk !== "string" &&
+    chunk !== undefined &&
+    !state.objectMode
+  ) {
+    er = new TypeError("Invalid non-string/buffer chunk");
   }
   if (er) {
-    stream.emit('error', er);
+    stream.emit("error", er);
     pna.nextTick(cb, er);
     valid = false;
   }
@@ -320,16 +349,18 @@ Writable.prototype.write = function (chunk, encoding, cb) {
     chunk = _uint8ArrayToBuffer(chunk);
   }
 
-  if (typeof encoding === 'function') {
+  if (typeof encoding === "function") {
     cb = encoding;
     encoding = null;
   }
 
-  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
+  if (isBuf) encoding = "buffer";
+  else if (!encoding) encoding = state.defaultEncoding;
 
-  if (typeof cb !== 'function') cb = nop;
+  if (typeof cb !== "function") cb = nop;
 
-  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
+  if (state.ended) writeAfterEnd(this, cb);
+  else if (isBuf || validChunk(this, state, chunk, cb)) {
     state.pendingcb++;
     ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
   }
@@ -349,33 +380,60 @@ Writable.prototype.uncork = function () {
   if (state.corked) {
     state.corked--;
 
-    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
+    if (
+      !state.writing &&
+      !state.corked &&
+      !state.bufferProcessing &&
+      state.bufferedRequest
+    )
+      clearBuffer(this, state);
   }
 };
 
 Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
   // node::ParseEncoding() requires lower case.
-  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
-  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
+  if (typeof encoding === "string") encoding = encoding.toLowerCase();
+  if (
+    !(
+      [
+        "hex",
+        "utf8",
+        "utf-8",
+        "ascii",
+        "binary",
+        "base64",
+        "ucs2",
+        "ucs-2",
+        "utf16le",
+        "utf-16le",
+        "raw",
+      ].indexOf((encoding + "").toLowerCase()) > -1
+    )
+  )
+    throw new TypeError("Unknown encoding: " + encoding);
   this._writableState.defaultEncoding = encoding;
   return this;
 };
 
 function decodeChunk(state, chunk, encoding) {
-  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
+  if (
+    !state.objectMode &&
+    state.decodeStrings !== false &&
+    typeof chunk === "string"
+  ) {
     chunk = Buffer.from(chunk, encoding);
   }
   return chunk;
 }
 
-Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
+Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
   // making it explicit this property is not enumerable
   // because otherwise some prototype manipulation in
   // userland will fail
   enumerable: false,
   get: function () {
     return this._writableState.highWaterMark;
-  }
+  },
 });
 
 // if we're already writing something, then just put this
@@ -386,7 +444,7 @@ function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
     var newChunk = decodeChunk(state, chunk, encoding);
     if (chunk !== newChunk) {
       isBuf = true;
-      encoding = 'buffer';
+      encoding = "buffer";
       chunk = newChunk;
     }
   }
@@ -405,7 +463,7 @@ function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
       encoding: encoding,
       isBuf: isBuf,
       callback: cb,
-      next: null
+      next: null,
     };
     if (last) {
       last.next = state.lastBufferedRequest;
@@ -425,7 +483,8 @@ function doWrite(stream, state, writev, len, chunk, encoding, cb) {
   state.writecb = cb;
   state.writing = true;
   state.sync = true;
-  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
+  if (writev) stream._writev(chunk, state.onwrite);
+  else stream._write(chunk, encoding, state.onwrite);
   state.sync = false;
 }
 
@@ -440,13 +499,13 @@ function onwriteError(stream, state, sync, er, cb) {
     // after error
     pna.nextTick(finishMaybe, stream, state);
     stream._writableState.errorEmitted = true;
-    stream.emit('error', er);
+    stream.emit("error", er);
   } else {
     // the caller expect this to happen before if
     // it is async
     cb(er);
     stream._writableState.errorEmitted = true;
-    stream.emit('error', er);
+    stream.emit("error", er);
     // this can emit finish, but finish must
     // always follow error
     finishMaybe(stream, state);
@@ -467,11 +526,17 @@ function onwrite(stream, er) {
 
   onwriteStateUpdate(state);
 
-  if (er) onwriteError(stream, state, sync, er, cb);else {
+  if (er) onwriteError(stream, state, sync, er, cb);
+  else {
     // Check if we're actually ready to finish, but don't emit yet
     var finished = needFinish(state);
 
-    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
+    if (
+      !finished &&
+      !state.corked &&
+      !state.bufferProcessing &&
+      state.bufferedRequest
+    ) {
       clearBuffer(stream, state);
     }
 
@@ -498,7 +563,7 @@ function afterWrite(stream, state, finished, cb) {
 function onwriteDrain(stream, state) {
   if (state.length === 0 && state.needDrain) {
     state.needDrain = false;
-    stream.emit('drain');
+    stream.emit("drain");
   }
 }
 
@@ -524,7 +589,7 @@ function clearBuffer(stream, state) {
     }
     buffer.allBuffers = allBuffers;
 
-    doWrite(stream, state, true, state.length, buffer, '', holder.finish);
+    doWrite(stream, state, true, state.length, buffer, "", holder.finish);
 
     // doWrite is almost always async, defer these to save a bit of time
     // as the hot path ends with doWrite
@@ -565,7 +630,7 @@ function clearBuffer(stream, state) {
 }
 
 Writable.prototype._write = function (chunk, encoding, cb) {
-  cb(new Error('_write() is not implemented'));
+  cb(new Error("_write() is not implemented"));
 };
 
 Writable.prototype._writev = null;
@@ -573,11 +638,11 @@ Writable.prototype._writev = null;
 Writable.prototype.end = function (chunk, encoding, cb) {
   var state = this._writableState;
 
-  if (typeof chunk === 'function') {
+  if (typeof chunk === "function") {
     cb = chunk;
     chunk = null;
     encoding = null;
-  } else if (typeof encoding === 'function') {
+  } else if (typeof encoding === "function") {
     cb = encoding;
     encoding = null;
   }
@@ -595,28 +660,34 @@ Writable.prototype.end = function (chunk, encoding, cb) {
 };
 
 function needFinish(state) {
-  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
+  return (
+    state.ending &&
+    state.length === 0 &&
+    state.bufferedRequest === null &&
+    !state.finished &&
+    !state.writing
+  );
 }
 function callFinal(stream, state) {
   stream._final(function (err) {
     state.pendingcb--;
     if (err) {
-      stream.emit('error', err);
+      stream.emit("error", err);
     }
     state.prefinished = true;
-    stream.emit('prefinish');
+    stream.emit("prefinish");
     finishMaybe(stream, state);
   });
 }
 function prefinish(stream, state) {
   if (!state.prefinished && !state.finalCalled) {
-    if (typeof stream._final === 'function') {
+    if (typeof stream._final === "function") {
       state.pendingcb++;
       state.finalCalled = true;
       pna.nextTick(callFinal, stream, state);
     } else {
       state.prefinished = true;
-      stream.emit('prefinish');
+      stream.emit("prefinish");
     }
   }
 }
@@ -627,7 +698,7 @@ function finishMaybe(stream, state) {
     prefinish(stream, state);
     if (state.pendingcb === 0) {
       state.finished = true;
-      stream.emit('finish');
+      stream.emit("finish");
     }
   }
   return need;
@@ -637,7 +708,8 @@ function endWritable(stream, state, cb) {
   state.ending = true;
   finishMaybe(stream, state);
   if (cb) {
-    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
+    if (state.finished) pna.nextTick(cb);
+    else stream.once("finish", cb);
   }
   state.ended = true;
   stream.writable = false;
@@ -657,7 +729,7 @@ function onCorkedFinish(corkReq, state, err) {
   state.corkedRequestsFree.next = corkReq;
 }
 
-Object.defineProperty(Writable.prototype, 'destroyed', {
+Object.defineProperty(Writable.prototype, "destroyed", {
   get: function () {
     if (this._writableState === undefined) {
       return false;
@@ -674,7 +746,7 @@ Object.defineProperty(Writable.prototype, 'destroyed', {
     // backward compatibility, the user is explicitly
     // managing destroyed
     this._writableState.destroyed = value;
-  }
+  },
 });
 
 Writable.prototype.destroy = destroyImpl.destroy;
